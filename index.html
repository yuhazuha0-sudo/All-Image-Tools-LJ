<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Primary Meta -->
  <title>All Image Tools ‚Äî Free Online Image Compressor (High Quality)</title>
  <meta name="description" content="All Image Tools: Free online high-quality image compressor with batch support, target KB/MB, percentage compression, auto intelligent mode, and WebP/JPEG conversion." />
  <meta name="keywords" content="image compressor, compress image online, reduce image size, photo compressor, batch image compressor, free image tool, webp converter, jpg compressor, png compressor" />

  <!-- Google Verification -->
  <meta name="google-site-verification" content="Qwac3UqKv3fpo4-b5ENzwdGoSKqIHasZwHz3ydy3Ong" />

  <!-- Canonical URL -->
  <link rel="canonical" href="https://yuhazuha0-sudo.github.io/All-Image-Tools/" />

  <!-- Open Graph (Facebook / WhatsApp Preview) -->
  <meta property="og:title" content="All Image Tools ‚Äî Free Online Image Compressor" />
  <meta property="og:description" content="Compress images without losing quality. Supports batch, auto, target size (KB/MB), percentage, and WebP conversion." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://yuhazuha0-sudo.github.io/All-Image-Tools/" />
  <meta property="og:image" content="https://yuhazuha0-sudo.github.io/All-Image-Tools/logo.png" />

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="All Image Tools ‚Äî Free Online Image Compressor" />
  <meta name="twitter:description" content="Fast, high-quality online image compressor with multiple methods." />
  <meta name="twitter:image" content="https://yuhazuha0-sudo.github.io/All-Image-Tools/logo.png" />

  <!-- Favicon (emoji favicon) -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üñºÔ∏è</text></svg>'">

  <!-- Your existing CSS continues below -->  <style>
    :root{
      --accent:#0b5fff;
      --bg:#f6f8fb;
      --card:#ffffff;
      --muted:#6b7280;
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;color:#111;background:var(--bg)}
    .container{max-width:1100px;margin:22px auto;padding:18px}
    header{display:flex;align-items:center;justify-content:space-between;gap:16px}
    h1{font-size:20px;margin:0}
    .card{background:var(--card);border-radius:12px;padding:16px;box-shadow:0 8px 30px rgba(12,20,40,0.06);margin-top:16px}
    .drop{border:2px dashed #e6eefc;border-radius:10px;padding:22px;text-align:center;color:var(--muted);cursor:pointer}
    .controls{display:flex;flex-wrap:wrap;gap:12px;margin-top:12px;align-items:center}
    .control{display:flex;gap:8px;align-items:center}
    select,input[type=number],input[type=text]{padding:8px;border-radius:8px;border:1px solid #e6eefc;background:#fbfdff}
    input[type=range]{vertical-align:middle}
    .files{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;margin-top:12px}
    .file-card{background:#fff;border-radius:10px;padding:10px;border:1px solid #f0f6ff;display:flex;flex-direction:column;gap:8px}
    .thumb{height:140px;object-fit:contain;background:#fbfdff;border-radius:6px;border:1px solid #eee}
    .row{display:flex;justify-content:space-between;align-items:center}
    button{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
    .muted{color:var(--muted);font-size:13px}
    .small{font-size:13px}
    .pill{background:#eef6ff;padding:6px 10px;border-radius:999px;color:var(--accent);font-weight:600}
    .flex{display:flex;gap:8px;align-items:center}
    .progress{height:8px;background:#f1f5f9;border-radius:6px;overflow:hidden}
    .progress span{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#7aa8ff);width:0%}
    .tooltip{font-size:12px;color:var(--muted)}
    .footer{margin-top:12px;color:var(--muted);font-size:13px;display:flex;justify-content:space-between;align-items:center}
    @media(max-width:700px){
      .controls{flex-direction:column;align-items:stretch}
    }
    /* preview comparison slider */
    .compare{position:relative;overflow:hidden;border-radius:6px;border:1px solid #eee}
    .compare img{width:100%;display:block}
    .compare .after{position:absolute;left:0;top:0;height:100%;width:50%;overflow:hidden}
    .compare input[type=range]{position:absolute;left:0;right:0;bottom:6px;width:calc(100% - 12px);margin:0 6px}
  </style>
  <!-- Libraries -->
  <script src="https://unpkg.com/browser-image-compression@1.0.17/dist/browser-image-compression.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
</head>
<body>
  <div class="container">
    <header>
      <div style="display:flex;align-items:center;gap:12px">
        <div class="pill">All Image Tools</div>
        <h1>Image Compressor ‚Äî Smart & Batch</h1>
      </div>
      <div class="muted small">Client-side ‚Ä¢ Privacy-first</div>
    </header>

    <div class="card">
      <div id="drop" class="drop">
        Drag & drop images here or <label style="color:var(--accent);text-decoration:underline;cursor:pointer"><input id="fileinput" type="file" accept="image/*" multiple style="display:none">choose files</label>
        <div class="tooltip" style="margin-top:8px">Supports JPEG, PNG, WebP. For very large PNGs try the 'Auto' or 'Light' mode.</div>
      </div>

      <div class="controls">
        <div class="control">
          <label class="small muted">Method</label>
          <select id="method">
            <option value="auto">Auto (Smart)</option>
            <option value="quality">Quality (slider)</option>
            <option value="targetKB">Target size (KB/MB)</option>
            <option value="percentage">Percentage reduction</option>
            <option value="dimension">Max width/height</option>
          </select>
        </div>

        <div class="control" id="qualityControl" style="display:none">
          <label class="small muted">Quality</label>
          <input id="quality" type="range" min="10" max="100" value="85">
          <span id="qval" class="small muted">85</span>
        </div>

        <!-- Replaced KB control with Target Size + unit (KB/MB) -->
        <div class="control" id="kbControl" style="display:none">
          <label class="small muted">Target size</label>
          <input id="targetSize" type="number" min="0" step="0.01" placeholder="e.g., 200 or 0.5" style="width:110px">
          <select id="targetUnit" style="padding:8px;border-radius:8px;border:1px solid #e6eefc;background:#fbfdff">
            <option value="KB">KB</option>
            <option value="MB">MB</option>
          </select>
        </div>

        <div class="control" id="percControl" style="display:none">
          <label class="small muted">Reduce %</label>
          <input id="percentage" type="number" min="1" max="99" placeholder="e.g., 60" style="width:110px">
        </div>

        <div class="control" id="dimControl" style="display:none">
          <label class="small muted">Max W / H</label>
          <input id="maxw" type="number" min="0" placeholder="W px" style="width:90px">
          <input id="maxh" type="number" min="0" placeholder="H px" style="width:90px">
        </div>

        <div class="control">
          <label class="small muted">Convert to</label>
          <select id="convert">
            <option value="keep">Keep</option>
            <option value="webp">WebP</option>
            <option value="jpeg">JPEG</option>
          </select>
        </div>

        <div class="control">
          <label class="small muted">Auto Preset</label>
          <select id="autoPreset">
            <option value="medium">Medium (recommended)</option>
            <option value="light">Light (quality-first)</option>
            <option value="extreme">Extreme (size-first)</option>
          </select>
        </div>

        <div class="control" style="margin-left:auto">
          <label class="small muted">Apply to all</label>
          <input id="applyAll" type="checkbox" checked>
        </div>
      </div>

      <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:12px">
        <button id="compressSelected">Compress Selected</button>
        <button id="compressAll">Compress All</button>
        <button id="downloadZip">Download All (ZIP)</button>
        <button id="clearAll" style="background:#ccc;color:#111">Clear</button>
      </div>

      <div id="files" class="files"></div>

      <div class="footer">
  <div>Tip: Use <strong>Auto</strong> for most images ‚Äî it balances quality & size automatically.</div>

  <div style="display:flex; gap:12px;">
    <a href="privacy.html" style="color:var(--accent);text-decoration:underline">Privacy Policy</a>
    <a href="terms.html" style="color:var(--accent);text-decoration:underline">Terms</a>
    <a href="contact.html" style="color:var(--accent);text-decoration:underline">Contact</a>
    <a href="#" id="donateBtn" style="color:var(--accent);text-decoration:underline">Donate</a>
  </div>
</div>

<script>
/*
  All Image Tools - client-side compressor (patched)
  - Reuses object URLs to avoid memory leaks
  - Revokes URLs on remove/replace
  - WebP feature-detect before encoding
  - Async alpha detection for PNG transparency
*/

const fileinput = document.getElementById('fileinput');
const drop = document.getElementById('drop');
const filesEl = document.getElementById('files');

const methodEl = document.getElementById('method');
const qualityEl = document.getElementById('quality');
const qval = document.getElementById('qval');
const targetSizeEl = document.getElementById('targetSize');
const targetUnitEl = document.getElementById('targetUnit');
const percentageEl = document.getElementById('percentage');
const maxwEl = document.getElementById('maxw');
const maxhEl = document.getElementById('maxh');
const convertEl = document.getElementById('convert');
const autoPreset = document.getElementById('autoPreset');
const applyAllEl = document.getElementById('applyAll');

const compressSelectedBtn = document.getElementById('compressSelected');
const compressAllBtn = document.getElementById('compressAll');
const downloadZipBtn = document.getElementById('downloadZip');
const clearAllBtn = document.getElementById('clearAll');

let items = []; // {id,file,objectURL,preview,compressedBlob,afterURL,selected,progress,estimated}
let idCounter = 1;

// feature-detect webp encoding support
function canEncodeWebP(){
  try{
    const c = document.createElement('canvas');
    return c.toDataURL && c.toDataURL('image/webp').indexOf('data:image/webp') === 0;
  }catch(e){ return false; }
}
const WEBP_SUPPORTED = canEncodeWebP();

function humanBytes(n){
  if(!n && n !== 0) return '-';
  if(n===0) return '0 B';
  const units=['B','KB','MB','GB'];
  let i=Math.floor(Math.log(n)/Math.log(1024));
  if(i<0) i=0;
  return (n/Math.pow(1024,i)).toFixed(2)+' '+units[i];
}

function render(){
  filesEl.innerHTML='';
  items.forEach((it, idx)=>{
    const div = document.createElement('div');
    div.className='file-card';
    div.dataset.id = it.id;
    // thumbnail
    const img = document.createElement('img'); img.className='thumb';
    // use preview (data url) or objectURL (created once)
    img.src = it.preview || it.objectURL;
    // info
    const info = document.createElement('div');
    info.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center">
      <div><strong style="font-size:14px">${it.file.name}</strong><div class="muted small">${it.file.type} ‚Ä¢ ${humanBytes(it.file.size)}</div></div>
      <div class="flex"><label class="small muted">Sel</label><input type="checkbox" class="sel" ${it.selected?'checked':''}></div>
    </div>`;

    const progWrap = document.createElement('div');
    progWrap.innerHTML = `<div class="progress" style="margin-top:6px"><span style="width:${(it.progress||0)}%"></span></div>`;

    const afterLine = document.createElement('div');
    afterLine.className='row small muted';
    const afterText = it.compressedBlob ? `${humanBytes(it.compressedBlob.size)} ‚Ä¢ saved ${((1 - (it.compressedBlob.size/it.file.size))*100).toFixed(1)}%` : 'Not compressed yet';
    afterLine.innerHTML = `<div>${afterText}</div><div>${it.estimated?'Est: '+humanBytes(it.estimated):''}</div>`;

    const actions = document.createElement('div');
    actions.className='row';
    const left = document.createElement('div');
    left.className='flex';
    const compBtn = document.createElement('button'); compBtn.textContent='Compress';
    compBtn.onclick = ()=>compressSingleById(it.id);
    const dlBtn = document.createElement('button'); dlBtn.textContent='Download';
    dlBtn.style.background='#10b981'; dlBtn.onclick = ()=>downloadSingle(it.id);
    const previewBtn = document.createElement('button'); previewBtn.textContent='Preview'; previewBtn.style.background='#6b7280';
    previewBtn.onclick = ()=>openPreview(it);
    const removeBtn = document.createElement('button'); removeBtn.textContent='Remove'; removeBtn.style.background='#ef4444';
    removeBtn.onclick = ()=>{ removeItemById(it.id); };

    left.appendChild(compBtn); left.appendChild(dlBtn); left.appendChild(previewBtn);
    const right = document.createElement('div');
    right.appendChild(removeBtn);
    actions.appendChild(left); actions.appendChild(right);

    div.appendChild(img); div.appendChild(info); div.appendChild(progWrap); div.appendChild(afterLine); div.appendChild(actions);
    filesEl.appendChild(div);
    // checkbox handler
    div.querySelector('.sel').addEventListener('change', (e)=>{
      it.selected = e.target.checked;
    });
  });
}

function addFiles(fileList){
  for(const f of fileList){
    if(!f.type.startsWith('image/')) continue;
    const id = idCounter++;
    const objectURL = URL.createObjectURL(f);
    items.push({id, file:f, objectURL, preview: null, compressedBlob:null, afterURL:null, selected:true, progress:0, estimated:null});
  }
  render();
  schedulePreviews();
}

function removeItemById(id){
  const it = items.find(x=>x.id===id);
  if(!it) return;
  // revoke URLs
  if(it.objectURL) { try{ URL.revokeObjectURL(it.objectURL); }catch(e){} }
  if(it.afterURL) { try{ URL.revokeObjectURL(it.afterURL); }catch(e){} }
  // preview may be dataURL (string) ‚Äî no revoke needed
  items = items.filter(x=>x.id!==id);
  render();
}

drop.addEventListener('click', ()=>fileinput.click());
// allow re-selecting same files by clearing input value after handling change
fileinput.addEventListener('change',(e)=>{ addFiles(e.target.files); fileinput.value = ''; });
drop.addEventListener('dragover', e=>{e.preventDefault(); drop.style.borderColor='#b5d1ff';});
drop.addEventListener('dragleave', e=>{drop.style.borderColor='#e6eefc';});
drop.addEventListener('drop', e=>{e.preventDefault(); drop.style.borderColor='#e6eefc'; addFiles(e.dataTransfer.files);});

methodEl.addEventListener('change', updateControls);
qualityEl.addEventListener('input', ()=>qval.textContent = qualityEl.value);
updateControls();

function updateControls(){
  const method = methodEl.value;
  document.getElementById('qualityControl').style.display = method==='quality' ? 'flex' : 'none';
  document.getElementById('kbControl').style.display = method==='targetKB' ? 'flex' : 'none';
  document.getElementById('percControl').style.display = method==='percentage' ? 'flex' : 'none';
  document.getElementById('dimControl').style.display = method==='dimension' ? 'flex' : 'none';
}

// parse target size (KB/MB) into bytes
function parseTargetBytes(){
  const raw = Number((targetSizeEl && targetSizeEl.value) ? targetSizeEl.value : 0);
  const unit = (targetUnitEl && targetUnitEl.value) ? targetUnitEl.value : 'KB';
  if(!raw || raw <= 0) return null;
  const factor = (unit === 'MB') ? 1024 * 1024 : 1024;
  return Math.round(raw * factor);
}

// Utility: simple edge/detail detector (returns detail score 0-255)
async function estimateDetail(file){
  try{
    const img = await loadImage(file);
    const canvas = document.createElement('canvas');
    const w = Math.min(img.width, 600);
    const h = Math.round(img.height * (w / img.width));
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img,0,0,w,h);
    const data = ctx.getImageData(0,0,w,h).data;
    // compute simple gradient variance / edge-like measure
    let sum=0, sumSq=0, cnt=0;
    for(let y=1;y<h-1;y+=2){
      for(let x=1;x<w-1;x+=2){
        const idx = (y*w + x)*4;
        const gx = getLum(data, idx+4) - getLum(data, idx-4);
        const gy = getLum(data, idx + (w*4)) - getLum(data, idx - (w*4));
        const g = Math.sqrt(gx*gx + gy*gy);
        sum += g; sumSq += g*g; cnt++;
      }
    }
    const mean = sum/cnt;
    const variance = Math.sqrt(Math.max(0, sumSq/cnt - mean*mean));
    const score = Math.min(255, Math.round(variance*8));
    return score;
  }catch(e){
    return 100; // default moderate detail
  }
}
function getLum(data, idx){ // idx points to R
  const r = data[idx], g = data[idx+1], b = data[idx+2];
  return 0.299*r + 0.587*g + 0.114*b;
}
function loadImage(file){
  return new Promise((res, rej)=>{
    const img = new Image();
    img.onload = ()=>res(img);
    img.onerror = rej;
    img.src = URL.createObjectURL(file);
  });
}

// async check for alpha channel by sampling image (returns boolean)
async function hasAlphaChannelAsync(file){
  try{
    if(!file.type.includes('png')) return false; // most alpha is PNG
    const img = await loadImage(file);
    const canvas = document.createElement('canvas');
    const w = Math.min(200, img.width);
    const h = Math.min(200, img.height);
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, w, h);
    const data = ctx.getImageData(0,0,w,h).data;
    for(let i=3;i<data.length;i+=4){
      if(data[i] < 255) return true;
    }
    return false;
  }catch(e){
    return true; // conservative: assume alpha if uncertain
  }
}

// Compression logic per file
async function compressFileWithStrategy(item, options){
  // options: {method, quality, targetBytes, maxWidthOrHeight, convert, autoPreset}
  const file = item.file;
  const origSize = file.size;
  let desiredFormat = options.convert === 'keep' ? null : options.convert;

  // Helper doCompress with given quality and source (source can be File/Blob)
  async function doCompressWithSource(sourceFile, q, maxWH){
    const cfg = {
      maxSizeMB: undefined,
      maxWidthOrHeight: maxWH || options.maxWidthOrHeight || undefined,
      useWebWorker: true,
      initialQuality: q,
    };
    if(desiredFormat === 'webp' && WEBP_SUPPORTED) cfg.fileType = 'image/webp';
    else if(desiredFormat === 'jpeg') cfg.fileType = 'image/jpeg';
    const blob = await imageCompression(sourceFile, cfg);
    return blob;
  }

  // If method is quality: single pass
  if(options.method === 'quality'){
    const q = Math.max(0.1, Math.min(1, options.quality));
    const blob = await doCompressWithSource(file, q);
    return blob;
  }

  // If dimension only
  if(options.method === 'dimension'){
    const cfg = { maxWidthOrHeight: options.maxWidthOrHeight || undefined, useWebWorker:true };
    if(desiredFormat === 'webp' && WEBP_SUPPORTED) cfg.fileType='image/webp';
    else if(desiredFormat === 'jpeg') cfg.fileType='image/jpeg';
    const blob = await imageCompression(file, cfg);
    return blob;
  }

  // Auto mode: pick base quality depending on detail & preset
  if(options.method === 'auto'){
    const detailScore = await estimateDetail(file); // 0-255
    // presets adjust base
    let base = 0.80;
    if(options.autoPreset === 'light') base = 0.88;
    else if(options.autoPreset === 'medium') base = 0.78;
    else if(options.autoPreset === 'extreme') base = 0.66;
    // adjust with detail: more detail -> higher quality
    const detailFactor = 1 + (Math.min(200, detailScore) / 600); // ~1 - 1.33
    let q = Math.min(0.98, base * detailFactor);

    // For transparent PNGs: skip lossy conversion if preserve alpha desired
    const hasAlpha = await hasAlphaChannelAsync(file);
    if(file.type === 'image/png' && hasAlpha) {
      if(desiredFormat === 'webp' && WEBP_SUPPORTED){
        // allow webp with alpha if supported
      } else {
        // prefer high quality keep
        q = Math.min(0.98, Math.max(q, 0.92));
      }
    }
    let blob = await doCompressWithSource(file, q);
    // Try to be a bit aggressive if size reduction is small
    if(blob.size > origSize * 0.9 && q > 0.5){
      q = q - 0.12;
      const blob2 = await doCompressWithSource(file, q);
      if(blob2.size < blob.size) blob = blob2;
    }
    return blob;
  }

  // Target bytes (targetKB or percentage) - improved iterative + resize fallback
  if(options.method === 'targetKB' || options.method === 'percentage'){
    const target = options.targetBytes;
    // validation
    if(!target || target <= 0) {
      // fallback to moderate compress
      return await doCompressWithSource(file, 0.75);
    }

    // iterative quality steps (from high -> low)
    const qualitySteps = [0.95,0.85,0.75,0.65,0.55,0.45,0.35,0.25];
    let bestBlob = null;
    let bestDiff = Infinity;
    let workingSource = file; // may become a resized Blob
    const maxResizeRounds = 3;

    for(let round=0; round<maxResizeRounds; round++){
      for(let qi=0; qi<qualitySteps.length; qi++){
        const q = qualitySteps[qi];
        try{
          const blob = await doCompressWithSource(workingSource, q, options.maxWidthOrHeight);
          const size = blob.size;
          const diff = size - target;
          // store best
          if(Math.abs(diff) < Math.abs(bestDiff)){
            bestBlob = blob; bestDiff = diff;
          }
          // update progress
          item.progress = Math.min(95, Math.round(((round*qualitySteps.length) + qi+1) / (maxResizeRounds*qualitySteps.length) * 95));
          updateProgressUI(item.id, item.progress);
          if(size <= target){
            return blob; // success
          }
        }catch(e){
          console.warn('Attempt compress error', e);
        }
      }
      // none reached target in this round -> downscale image by 10% and retry
      try{
        const img = await loadImage(workingSource);
        const newW = Math.max(100, Math.round(img.width * 0.90));
        const newH = Math.max(100, Math.round(img.height * 0.90));
        const canvas = document.createElement('canvas');
        canvas.width = newW; canvas.height = newH;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, newW, newH);
        const mime = (options.convert === 'webp' && WEBP_SUPPORTED) ? 'image/webp' : (options.convert === 'jpeg' ? 'image/jpeg' : 'image/jpeg');
        // using quality 0.9 for resized blob creation
        const resizedBlob = await new Promise(res => canvas.toBlob(res, mime, 0.9));
        workingSource = resizedBlob;
      }catch(e){
        console.warn('Resize attempt failed', e);
        break;
      }
    }

    // fallback to best found
    if(bestBlob) return bestBlob;

    // last fallback
    return await doCompressWithSource(file, 0.6);
  }

  // fallback
  return await doCompressWithSource(file, options.quality || 0.8);
}

// Queue with concurrency
let running = 0;
const CONCURRENCY = 2;
const queue = [];

function enqueue(task){
  queue.push(task);
  runQueue();
}
function runQueue(){
  if(running >= CONCURRENCY) return;
  const task = queue.shift();
  if(!task) return;
  running++;
  task().finally(()=>{ running--; runQueue(); });
}

// Update progress UI
function updateProgressUI(id, percent){
  const el = [...filesEl.children].find(div=>Number(div.dataset.id)===id);
  if(!el) return;
  const bar = el.querySelector('.progress span');
  if(bar) bar.style.width = percent + '%';
  // update after text too
  const it = items.find(x=>x.id===id);
  if(it){
    const afterLine = el.querySelectorAll('.row.small.muted')[1];
    if(afterLine){
      afterLine.innerHTML = `<div>${it.compressedBlob ? humanBytes(it.compressedBlob.size)+' ‚Ä¢ saved '+((1 - (it.compressedBlob.size/it.file.size))*100).toFixed(1)+'%' : 'Not compressed yet'}</div><div>${it.estimated?'Est: '+humanBytes(it.estimated):''}</div>`;
    }
  }
}

// find item by id and compress
function compressSingleById(id){
  const it = items.find(x=>x.id===id);
  if(it) enqueue(()=>compressItemWorkflow(it));
}

// Main compress workflow for an item
async function compressItemWorkflow(item){
  try{
    item.progress = 5; updateProgressUI(item.id, item.progress);
    // build options from UI (if applyAll checked, use global; else per-file future extension)
    const method = methodEl.value;
    const opts = {};
    opts.method = method;
    opts.convert = convertEl.value;
    if(method === 'quality'){
      opts.quality = qualityEl.value/100;
    } else if(method === 'targetKB'){
      const tb = parseTargetBytes();
      if(!tb){
        alert('Please enter a valid target size (e.g., 200 KB or 0.5 MB).');
        item.progress = 0; updateProgressUI(item.id, item.progress);
        return;
      }
      // unrealistic tiny target? warn
      if(tb < 1024){
        if(!confirm('Target size under 1 KB is unrealistic and may drastically reduce quality. Proceed?')) { item.progress = 0; updateProgressUI(item.id, item.progress); return; }
      }
      opts.targetBytes = tb;
    } else if(method === 'percentage'){
      const perc = Number(percentageEl.value) || 60;
      opts.targetBytes = Math.max(1000, Math.floor(item.file.size * (1 - (perc/100))));
    } else if(method === 'dimension'){
      const mw = Number(maxwEl.value) || 0;
      const mh = Number(maxhEl.value) || 0;
      opts.maxWidthOrHeight = mw || mh || undefined;
    } else if(method === 'auto'){
      opts.autoPreset = autoPreset.value;
    }
    // show estimate (quick pass using quality guess)
    item.estimated = humanBytes(Math.round(item.file.size * (method==='percentage' ? (1 - (Number(percentageEl.value || 60)/100)) : 0.6)));
    updateProgressUI(item.id, item.progress);
    // run compression (enqueue heavy op)
    const blob = await compressFileWithStrategy(item, opts);
    // revoke old afterURL if present
    if(item.afterURL) { try{ URL.revokeObjectURL(item.afterURL); }catch(e){} }
    item.compressedBlob = blob;
    item.afterURL = URL.createObjectURL(blob);
    item.progress = 100;
    updateProgressUI(item.id, item.progress);
    render();
  }catch(err){
    console.error('Compress error', err);
    alert('Compression failed for '+item.file.name+': '+err.message);
    item.progress = 0;
    updateProgressUI(item.id, item.progress);
  }
}

// helpers to compress selected/all
compressSelectedBtn.addEventListener('click', ()=>{
  const selected = items.filter(it=>it.selected);
  if(selected.length===0){ alert('Select at least one file'); return; }
  selected.forEach(it => enqueue(()=>compressItemWorkflow(it)));
});
compressAllBtn.addEventListener('click', ()=>{
  if(items.length===0){ alert('Add files first'); return; }
  items.forEach(it => enqueue(()=>compressItemWorkflow(it)));
});

// Download single
function downloadSingle(id){
  const it = items.find(x=>x.id===id);
  if(!it) return;
  const blob = it.compressedBlob || it.file;
  const ext = (blob.type && blob.type.split('/')[1]) || it.file.name.split('.').pop();
  const name = it.file.name.replace(/\.[^/.]+$/, '') + '.' + ext;
  saveAs(blob, name);
}

// Preview modal with before/after slider
function openPreview(item){
  // create modal
  const modal = document.createElement('div');
  Object.assign(modal.style,{position:'fixed',left:0,top:0,right:0,bottom:0,background:'rgba(0,0,0,0.6)',display:'flex',alignItems:'center',justifyContent:'center',zIndex:9999});
  const box = document.createElement('div'); box.style.width='90%'; box.style.maxWidth='900px'; box.style.background='#fff'; box.style.borderRadius='10px'; box.style.padding='12px';
  const title = document.createElement('div'); title.innerHTML = `<strong>${item.file.name}</strong> <span class="muted" style="margin-left:8px">${humanBytes(item.file.size)} ‚Üí ${item.compressedBlob?humanBytes(item.compressedBlob.size):'n/a'}</span>`;
  const comp = document.createElement('div'); comp.className='compare'; comp.style.marginTop='8px';
  const beforeImg = document.createElement('img'); beforeImg.src = item.preview || item.objectURL;
  const afterWrap = document.createElement('div'); afterWrap.className='after';
  const afterImg = document.createElement('img'); afterImg.src = item.afterURL || (item.compressedBlob ? item.afterURL : beforeImg.src);
  afterWrap.appendChild(afterImg);
  comp.appendChild(beforeImg); comp.appendChild(afterWrap);
  const slider = document.createElement('input'); slider.type='range'; slider.min=0; slider.max=100; slider.value=50;
  slider.addEventListener('input', ()=>{ afterWrap.style.width = slider.value + '%'; });
  const ctrls = document.createElement('div'); ctrls.style.display='flex'; ctrls.style.justifyContent='space-between'; ctrls.style.marginTop='8px';
  const close = document.createElement('button'); close.textContent='Close'; close.onclick = ()=>document.body.removeChild(modal);
  const download = document.createElement('button'); download.textContent='Download'; download.style.background='#10b981';
  download.onclick = ()=>{ downloadSingle(item.id); };
  ctrls.appendChild(download); ctrls.appendChild(close);
  box.appendChild(title); box.appendChild(comp); box.appendChild(slider); box.appendChild(ctrls);
  modal.appendChild(box);
  document.body.appendChild(modal);
}

// ZIP download
downloadZipBtn.addEventListener('click', async ()=>{
  if(items.length===0){ alert('No files'); return; }
  const zip = new JSZip();
  // ensure compressed blobs exist; compress if needed (sequential)
  for(const it of items){
    if(!it.compressedBlob){
      // compress on the fly with default options
      await new Promise(res=>enqueue(async ()=>{ await compressItemWorkflow(it); res(); }));
    }
    const blob = it.compressedBlob || it.file;
    const ext = (blob.type && blob.type.split('/')[1]) || it.file.name.split('.').pop();
    const name = it.file.name.replace(/\.[^/.]+$/, '') + '.' + ext;
    const arr = await blob.arrayBuffer();
    zip.file(name, arr);
  }
  const content = await zip.generateAsync({type:'blob'}, (meta)=>{ /* Could show progress */ });
  saveAs(content, 'all-images-compressed.zip');
});

// Clear
clearAllBtn.addEventListener('click', ()=>{ if(confirm('Clear all files?')){ // revoke all URLs
  items.forEach(it => { if(it.objectURL) try{ URL.revokeObjectURL(it.objectURL);}catch(e){}; if(it.afterURL) try{ URL.revokeObjectURL(it.afterURL);}catch(e){}; });
  items=[]; render(); } });

// small UX: generate preview thumbnails (smaller)
async function generatePreviewForAll(){
  for(const it of items){
    try{
      const p = await createThumbnail(it.file, 400);
      // revoke old preview if it was blob (ours are dataURLs so no revoke)
      it.preview = p;
    }catch(e){}
  }
  render();
}
async function createThumbnail(file, maxSize){
  const img = await loadImage(file);
  const ratio = img.width / img.height;
  const w = Math.min(maxSize, img.width);
  const h = Math.round(w / ratio);
  const canvas = document.createElement('canvas'); canvas.width=w; canvas.height=h;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img,0,0,w,h);
  return canvas.toDataURL('image/jpeg', 0.7);
}

// create initial previews on add
const obs = new MutationObserver(()=>{ /* placeholder */ });
obs.observe(filesEl, {childList:true});

// whenever items change, create preview thumbnails (but debounce)
let previewTimeout = null;
function schedulePreviews(){
  if(previewTimeout) clearTimeout(previewTimeout);
  previewTimeout = setTimeout(()=>{ generatePreviewForAll(); previewTimeout=null; }, 300);
}

// small helper to override addFiles reference used earlier
window.addFiles = addFiles;

// donate button (placeholder - change to your actual link)
document.getElementById('donateBtn').addEventListener('click', ()=>{
  window.open('https://www.buymeacoffee.com/yourname','_blank');
});

// initial render
render();

</script>
</body>
</html>
