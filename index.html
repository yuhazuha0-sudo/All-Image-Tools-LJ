<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>All Image Tools — Image Compressor</title>
  <meta name="description" content="All Image Tools - Client-side image compressor with smart auto-optimization, batch compress, target KB/MB, percentage reduction, quality slider and more.">
  <link rel="icon" href="data:,">
  <style>
    :root{
      --accent:#0b5fff;
      --bg:#f6f8fb;
      --card:#ffffff;
      --muted:#6b7280;
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;color:#111;background:var(--bg)}
    .container{max-width:1100px;margin:22px auto;padding:18px}
    header{display:flex;align-items:center;justify-content:space-between;gap:16px}
    h1{font-size:20px;margin:0}
    .card{background:var(--card);border-radius:12px;padding:16px;box-shadow:0 8px 30px rgba(12,20,40,0.06);margin-top:16px}
    .drop{border:2px dashed #e6eefc;border-radius:10px;padding:22px;text-align:center;color:var(--muted);cursor:pointer}
    .controls{display:flex;flex-wrap:wrap;gap:12px;margin-top:12px;align-items:center}
    .control{display:flex;gap:8px;align-items:center}
    select,input[type=number],input[type=text]{padding:8px;border-radius:8px;border:1px solid #e6eefc;background:#fbfdff}
    input[type=range]{vertical-align:middle}
    .files{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;margin-top:12px}
    .file-card{background:#fff;border-radius:10px;padding:10px;border:1px solid #f0f6ff;display:flex;flex-direction:column;gap:8px}
    .thumb{height:140px;object-fit:contain;background:#fbfdff;border-radius:6px;border:1px solid #eee}
    .row{display:flex;justify-content:space-between;align-items:center}
    button{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
    .muted{color:var(--muted);font-size:13px}
    .small{font-size:13px}
    .pill{background:#eef6ff;padding:6px 10px;border-radius:999px;color:var(--accent);font-weight:600}
    .flex{display:flex;gap:8px;align-items:center}
    .progress{height:8px;background:#f1f5f9;border-radius:6px;overflow:hidden}
    .progress span{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#7aa8ff);width:0%}
    .tooltip{font-size:12px;color:var(--muted)}
    .footer{margin-top:12px;color:var(--muted);font-size:13px;display:flex;justify-content:space-between;align-items:center}
    @media(max-width:700px){
      .controls{flex-direction:column;align-items:stretch}
    }
    /* preview comparison slider */
    .compare{position:relative;overflow:hidden;border-radius:6px;border:1px solid #eee}
    .compare img{width:100%;display:block}
    .compare .after{position:absolute;left:0;top:0;height:100%;width:50%;overflow:hidden}
    .compare input[type=range]{position:absolute;left:0;right:0;bottom:6px;width:calc(100% - 12px);margin:0 6px}
  </style>
  <!-- Libraries -->
  <script src="https://unpkg.com/browser-image-compression@1.0.17/dist/browser-image-compression.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
</head>
<body>
  <div class="container">
    <header>
      <div style="display:flex;align-items:center;gap:12px">
        <div class="pill">All Image Tools</div>
        <h1>Image Compressor — Smart & Batch</h1>
      </div>
      <div class="muted small">Client-side • Privacy-first</div>
    </header>

    <div class="card">
      <div id="drop" class="drop">
        Drag & drop images here or <label style="color:var(--accent);text-decoration:underline;cursor:pointer"><input id="fileinput" type="file" accept="image/*" multiple style="display:none">choose files</label>
        <div class="tooltip" style="margin-top:8px">Supports JPEG, PNG, WebP. For very large PNGs try the 'Auto' or 'Light' mode.</div>
      </div>

      <div class="controls">
        <div class="control">
          <label class="small muted">Method</label>
          <select id="method">
            <option value="auto">Auto (Smart)</option>
            <option value="quality">Quality (slider)</option>
            <option value="targetKB">Target size (KB/MB)</option>
            <option value="percentage">Percentage reduction</option>
            <option value="dimension">Max width/height</option>
          </select>
        </div>

        <div class="control" id="qualityControl" style="display:none">
          <label class="small muted">Quality</label>
          <input id="quality" type="range" min="10" max="100" value="85">
          <span id="qval" class="small muted">85</span>
        </div>

        <!-- Replaced KB control with Target Size + unit (KB/MB) -->
        <div class="control" id="kbControl" style="display:none">
          <label class="small muted">Target size</label>
          <input id="targetSize" type="number" min="0" step="0.01" placeholder="e.g., 200 or 0.5" style="width:110px">
          <select id="targetUnit" style="padding:8px;border-radius:8px;border:1px solid #e6eefc;background:#fbfdff">
            <option value="KB">KB</option>
            <option value="MB">MB</option>
          </select>
        </div>

        <div class="control" id="percControl" style="display:none">
          <label class="small muted">Reduce %</label>
          <input id="percentage" type="number" min="1" max="99" placeholder="e.g., 60" style="width:110px">
        </div>

        <div class="control" id="dimControl" style="display:none">
          <label class="small muted">Max W / H</label>
          <input id="maxw" type="number" min="0" placeholder="W px" style="width:90px">
          <input id="maxh" type="number" min="0" placeholder="H px" style="width:90px">
        </div>

        <div class="control">
          <label class="small muted">Convert to</label>
          <select id="convert">
            <option value="keep">Keep</option>
            <option value="webp">WebP</option>
            <option value="jpeg">JPEG</option>
          </select>
        </div>

        <div class="control">
          <label class="small muted">Auto Preset</label>
          <select id="autoPreset">
            <option value="medium">Medium (recommended)</option>
            <option value="light">Light (quality-first)</option>
            <option value="extreme">Extreme (size-first)</option>
          </select>
        </div>

        <div class="control" style="margin-left:auto">
          <label class="small muted">Apply to all</label>
          <input id="applyAll" type="checkbox" checked>
        </div>
      </div>

      <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:12px">
        <button id="compressSelected">Compress Selected</button>
        <button id="compressAll">Compress All</button>
        <button id="downloadZip">Download All (ZIP)</button>
        <button id="clearAll" style="background:#ccc;color:#111">Clear</button>
      </div>

      <div id="files" class="files"></div>

      <div class="footer">
        <div>Tip: Use <strong>Auto</strong> for most images — it balances quality & size automatically.</div>
        <div><a href="#" id="donateBtn" style="color:var(--accent);text-decoration:underline">Donate</a></div>
      </div>
    </div>
  </div>

<script>
/*
  All Image Tools - client-side compressor
  Uses browser-image-compression, JSZip, FileSaver
  Features:
    - Multi-file
    - Methods: auto, quality, targetKB/MB, percentage, dimension
    - Auto mode uses simple edge/detail detection to pick quality strategy
    - Iterative approach for targetKB/percentage with resize fallback
    - Concurrency queue (2 at a time)
*/

const fileinput = document.getElementById('fileinput');
const drop = document.getElementById('drop');
const filesEl = document.getElementById('files');

const methodEl = document.getElementById('method');
const qualityEl = document.getElementById('quality');
const qval = document.getElementById('qval');
const targetSizeEl = document.getElementById('targetSize');
const targetUnitEl = document.getElementById('targetUnit');
const percentageEl = document.getElementById('percentage');
const maxwEl = document.getElementById('maxw');
const maxhEl = document.getElementById('maxh');
const convertEl = document.getElementById('convert');
const autoPreset = document.getElementById('autoPreset');
const applyAllEl = document.getElementById('applyAll');

const compressSelectedBtn = document.getElementById('compressSelected');
const compressAllBtn = document.getElementById('compressAll');
const downloadZipBtn = document.getElementById('downloadZip');
const clearAllBtn = document.getElementById('clearAll');

let items = []; // {id,file,blob,compressedBlob,selected,progress,estSize}
let idCounter = 1;

function humanBytes(n){
  if(!n && n !== 0) return '-';
  if(n===0) return '0 B';
  const units=['B','KB','MB','GB'];
  let i=Math.floor(Math.log(n)/Math.log(1024));
  if(i<0) i=0;
  return (n/Math.pow(1024,i)).toFixed(2)+' '+units[i];
}

function render(){
  filesEl.innerHTML='';
  items.forEach((it, idx)=>{
    const div = document.createElement('div');
    div.className='file-card';
    div.dataset.id = it.id;
    // thumbnail
    const img = document.createElement('img'); img.className='thumb';
    img.src = it.preview || URL.createObjectURL(it.file);
    // info
    const info = document.createElement('div');
    info.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center">
      <div><strong style="font-size:14px">${it.file.name}</strong><div class="muted small">${it.file.type} • ${humanBytes(it.file.size)}</div></div>
      <div class="flex"><label class="small muted">Sel</label><input type="checkbox" class="sel" ${it.selected?'checked':''}></div>
    </div>`;

    const progWrap = document.createElement('div');
    progWrap.innerHTML = `<div class="progress" style="margin-top:6px"><span style="width:${(it.progress||0)}%"></span></div>`;

    const afterLine = document.createElement('div');
    afterLine.className='row small muted';
    const afterText = it.compressedBlob ? `${humanBytes(it.compressedBlob.size)} • saved ${((1 - (it.compressedBlob.size/it.file.size))*100).toFixed(1)}%` : 'Not compressed yet';
    afterLine.innerHTML = `<div>${afterText}</div><div>${it.estimated?'Est: '+humanBytes(it.estimated):''}</div>`;

    const actions = document.createElement('div');
    actions.className='row';
    const left = document.createElement('div');
    left.className='flex';
    const compBtn = document.createElement('button'); compBtn.textContent='Compress';
    compBtn.onclick = ()=>compressSingleById(it.id);
    const dlBtn = document.createElement('button'); dlBtn.textContent='Download';
    dlBtn.style.background='#10b981'; dlBtn.onclick = ()=>downloadSingle(it.id);
    const previewBtn = document.createElement('button'); previewBtn.textContent='Preview'; previewBtn.style.background='#6b7280';
    previewBtn.onclick = ()=>openPreview(it);
    const removeBtn = document.createElement('button'); removeBtn.textContent='Remove'; removeBtn.style.background='#ef4444';
    removeBtn.onclick = ()=>{ items = items.filter(x=>x.id!==it.id); render(); };

    left.appendChild(compBtn); left.appendChild(dlBtn); left.appendChild(previewBtn);
    const right = document.createElement('div');
    right.appendChild(removeBtn);
    actions.appendChild(left); actions.appendChild(right);

    div.appendChild(img); div.appendChild(info); div.appendChild(progWrap); div.appendChild(afterLine); div.appendChild(actions);
    filesEl.appendChild(div);
    // checkbox handler
    div.querySelector('.sel').addEventListener('change', (e)=>{
      it.selected = e.target.checked;
    });
  });
}

function addFiles(fileList){
  for(const f of fileList){
    if(!f.type.startsWith('image/')) continue;
    const id = idCounter++;
    items.push({id, file:f, compressedBlob:null, selected:true, progress:0, preview: null, estimated:null});
  }
  render();
}

drop.addEventListener('click', ()=>fileinput.click());
// allow re-selecting same files by clearing input value after handling change
fileinput.addEventListener('change',(e)=>{ addFiles(e.target.files); fileinput.value = ''; });
drop.addEventListener('dragover', e=>{e.preventDefault(); drop.style.borderColor='#b5d1ff';});
drop.addEventListener('dragleave', e=>{drop.style.borderColor='#e6eefc';});
drop.addEventListener('drop', e=>{e.preventDefault(); drop.style.borderColor='#e6eefc'; addFiles(e.dataTransfer.files);});

methodEl.addEventListener('change', updateControls);
qualityEl.addEventListener('input', ()=>qval.textContent = qualityEl.value);
updateControls();

function updateControls(){
  const method = methodEl.value;
  document.getElementById('qualityControl').style.display = method==='quality' ? 'flex' : 'none';
  document.getElementById('kbControl').style.display = method==='targetKB' ? 'flex' : 'none';
  document.getElementById('percControl').style.display = method==='percentage' ? 'flex' : 'none';
  document.getElementById('dimControl').style.display = method==='dimension' ? 'flex' : 'none';
}

// parse target size (KB/MB) into bytes
function parseTargetBytes(){
  const raw = Number((targetSizeEl && targetSizeEl.value) ? targetSizeEl.value : 0);
  const unit = (targetUnitEl && targetUnitEl.value) ? targetUnitEl.value : 'KB';
  if(!raw || raw <= 0) return null;
  const factor = (unit === 'MB') ? 1024 * 1024 : 1024;
  return Math.round(raw * factor);
}

// Utility: simple edge/detail detector (returns detail score 0-255)
async function estimateDetail(file){
  try{
    const img = await loadImage(file);
    const canvas = document.createElement('canvas');
    const w = Math.min(img.width, 600);
    const h = Math.round(img.height * (w / img.width));
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img,0,0,w,h);
    const data = ctx.getImageData(0,0,w,h).data;
    // compute simple gradient variance / edge-like measure
    let sum=0, sumSq=0, cnt=0;
    for(let y=1;y<h-1;y+=2){
      for(let x=1;x<w-1;x+=2){
        const idx = (y*w + x)*4;
        const gx = getLum(data, idx+4) - getLum(data, idx-4);
        const gy = getLum(data, idx + (w*4)) - getLum(data, idx - (w*4));
        const g = Math.sqrt(gx*gx + gy*gy);
        sum += g; sumSq += g*g; cnt++;
      }
    }
    const mean = sum/cnt;
    const variance = Math.sqrt(Math.max(0, sumSq/cnt - mean*mean));
    const score = Math.min(255, Math.round(variance*8));
    return score;
  }catch(e){
    return 100; // default moderate detail
  }
}
function getLum(data, idx){ // idx points to R
  const r = data[idx], g = data[idx+1], b = data[idx+2];
  return 0.299*r + 0.587*g + 0.114*b;
}
function loadImage(file){
  return new Promise((res, rej)=>{
    const img = new Image();
    img.onload = ()=>res(img);
    img.onerror = rej;
    img.src = URL.createObjectURL(file);
  });
}

// Compression logic per file
async function compressFileWithStrategy(item, options){
  // options: {method, quality, targetBytes, maxWidthOrHeight, convert, autoPreset}
  const file = item.file;
  const origSize = file.size;
  let desiredFormat = options.convert === 'keep' ? null : options.convert;
  let resultBlob = null;
  let attempt = 0;

  // Helper doCompress with given quality and source (source can be File/Blob)
  async function doCompressWithSource(sourceFile, q, maxWH){
    const cfg = {
      maxSizeMB: undefined,
      maxWidthOrHeight: maxWH || options.maxWidthOrHeight || undefined,
      useWebWorker: true,
      initialQuality: q,
    };
    if(desiredFormat === 'webp') cfg.fileType = 'image/webp';
    else if(desiredFormat === 'jpeg') cfg.fileType = 'image/jpeg';
    const blob = await imageCompression(sourceFile, cfg);
    return blob;
  }

  // If method is quality: single pass
  if(options.method === 'quality'){
    const q = Math.max(0.1, Math.min(1, options.quality));
    const blob = await doCompressWithSource(file, q);
    return blob;
  }

  // If dimension only
  if(options.method === 'dimension'){
    const cfg = { maxWidthOrHeight: options.maxWidthOrHeight || undefined, useWebWorker:true };
    if(desiredFormat === 'webp') cfg.fileType='image/webp';
    else if(desiredFormat === 'jpeg') cfg.fileType='image/jpeg';
    const blob = await imageCompression(file, cfg);
    return blob;
  }

  // Auto mode: pick base quality depending on detail & preset
  if(options.method === 'auto'){
    const detailScore = await estimateDetail(file); // 0-255
    // presets adjust base
    let base = 0.80;
    if(options.autoPreset === 'light') base = 0.88;
    else if(options.autoPreset === 'medium') base = 0.78;
    else if(options.autoPreset === 'extreme') base = 0.66;
    // adjust with detail: more detail -> higher quality
    const detailFactor = 1 + (Math.min(200, detailScore) / 600); // ~1 - 1.33
    let q = Math.min(0.98, base * detailFactor);
    // For transparent PNGs: skip lossy conversion if preserve alpha desired
    if(file.type === 'image/png' && hasAlphaChannel(file)) {
      if(desiredFormat === 'webp'){
        // allow webp with alpha
      } else {
        // prefer high quality keep
        q = Math.min(0.98, Math.max(q, 0.92));
      }
    }
    let blob = await doCompressWithSource(file, q);
    // Try to be a bit aggressive if size reduction is small
    if(blob.size > origSize * 0.9 && q > 0.5){
      q = q - 0.12;
      const blob2 = await doCompressWithSource(file, q);
      if(blob2.size < blob.size) blob = blob2;
    }
    return blob;
  }

  // Target bytes (targetKB or percentage) - improved iterative + resize fallback
  if(options.method === 'targetKB' || options.method === 'percentage'){
    const target = options.targetBytes;
    // validation
    if(!target || target <= 0) {
      // fallback to moderate compress
      return await doCompressWithSource(file, 0.75);
    }

    // iterative quality steps (from high -> low)
    const qualitySteps = [0.95,0.85,0.75,0.65,0.55,0.45,0.35,0.25];
    let bestBlob = null;
    let bestDiff = Infinity;
    let workingSource = file; // may become a resized Blob
    const maxResizeRounds = 3;

    for(let round=0; round<maxResizeRounds; round++){
      for(let qi=0; qi<qualitySteps.length; qi++){
        const q = qualitySteps[qi];
        try{
          const blob = await doCompressWithSource(workingSource, q, options.maxWidthOrHeight);
          const size = blob.size;
          const diff = size - target;
          // store best
          if(Math.abs(diff) < Math.abs(bestDiff)){
            bestBlob = blob; bestDiff = diff;
          }
          // update progress
          item.progress = Math.min(95, Math.round(((round*qualitySteps.length) + qi+1) / (maxResizeRounds*qualitySteps.length) * 95));
          updateProgressUI(item.id, item.progress);
          if(size <= target){
            return blob; // success
          }
        }catch(e){
          console.warn('Attempt compress error', e);
        }
      }
      // none reached target in this round -> downscale image by 10% and retry
      try{
        const img = await loadImage(workingSource);
        const newW = Math.max(100, Math.round(img.width * 0.90));
        const newH = Math.max(100, Math.round(img.height * 0.90));
        const canvas = document.createElement('canvas');
        canvas.width = newW; canvas.height = newH;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, newW, newH);
        const mime = (options.convert === 'webp') ? 'image/webp' : (options.convert === 'jpeg' ? 'image/jpeg' : 'image/jpeg');
        // using quality 0.9 for resized blob creation
        const resizedBlob = await new Promise(res => canvas.toBlob(res, mime, 0.9));
        workingSource = resizedBlob;
      }catch(e){
        console.warn('Resize attempt failed', e);
     
